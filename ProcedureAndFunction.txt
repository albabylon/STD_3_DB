Хранимые процедуры

Иногда бывают ситуации, когда логику работы с данными удобнее описать в самой базе, её собственными средствами. 
Для этого используются хранимые процедуры.

Например, хранимая процедура может реализовать логику принятия заказа от клиента или перевода денег из одного банка в другой.

Хранимые процедуры, по сути, превращают SQL в настоящий язык программирования, 
поскольку в них вы можете использовать условные выражения, циклы, определять переменные и другие конструкции

Все эти конструкции определяются в языке базы данных. У каждой базы свой язык, у PostgreSQL этот язык называется PL/pgSQL

Когда вся логика по работе с данными реализована в программе, 
то для выполнения любой SQL-операции сначала приходится отправлять запрос к базе по сети и потом ждать ответа

Недостатком является «размазывание» логики между программой и базой, что может усложнить понимание логики работы вашей системы

Для того чтобы просто выполнить код на языке PL/pgSQL, без объявления процедуры, используется do-блок:

DO $$ BEGIN /* тут ваш код */
END $$;

ИЛИ

DO $$ DECLARE 
/* переменные */
BEGIN 
/* код */
END $$;


!!!Каждая процедура должна заканчиваться точкой с запятой, это важно. 
Два знака доллара нужны для того, чтобы пометить, где начинается и где заканчивается код.!!!

Пример:

DO $$ DECLARE i INTEGER;
--объявление переменной
BEGIN FOR i IN 1..10 --начало цикла
LOOP EXECUTE (
  'create table temp_table_' || i || '(x int);'
);
END LOOP;
--конец цикла
END $$;


DO $$
DECLARE
         i INTEGER;
         j INTEGER;
         q TEXT;
BEGIN
         FOR i IN 1..120 LOOP
                 q = 'create table temp_table_' || i || '(';
                 FOR j IN 1..20 LOOP
                         IF j <> 1 THEN
                                 q = q || ',';
                         END IF;
                         q = q || 'attr_' || j || ' int';
                 END LOOP;
                 q = q || ');';
                 EXECUTE q;
         END LOOP;
END $$;


Вложенные блоки обязательно закрываются с помощью инструкции END, 
которая заканчивает блоки для вложенного цикла и выражения IF.

В Postgres для того чтобы создать хранимую процедуру, вы можете объявить функцию или процедуру. 
Отличие между ними в том, что процедура никогда не возвращает значение, а функция может возвращать.

Создадим процедуру с именем create_table:

CREATE 
OR REPLACE PROCEDURE create_table(name TEXT) AS $$ BEGIN EXECUTE (  'create table ' || name || '(str varchar(100));'
);
END $$ LANGUAGE 'plpgsql'

Важно не путать использование BEGIN/END для группировки операторов в PL/pgSQL с одноимёнными SQL-командами для управления транзакциями. 
BEGIN/END в PL/pgSQL служат только для группировки предложений; они не начинают и не заканчивают транзакции.

Конец процедуры нужно указывать явно, это делается в последней строке кода. 
Это связано с тем, что хранимые процедуры для PostgreSQL можно писать не только на PL/pgSQL, но и на других языках, в частности, на Perl, Python и JavaScript.


Для того чтобы вызвать процедуру, используется инструкция CALL:

DO $$ BEGIN CALL create_table('tmp_table' :: TEXT);
END $$;


Объявление функции очень похоже на объявление процедуры:

CREATE OR REPLACE FUNCTION gen_abra_cadabra(len INT)
RETURNS TEXT AS
$$ DECLARE
res TEXT := 'abra cadabra ';
     BEGIN
     WHILE LENGTH(res) <= len
         LOOP
         res := res || res;
         END LOOP;
     RETURN SUBSTRING(res, 1, len);
END $$ LANGUAGE 'plpgsql';


Вызвать эту процедуру вы можете с помощью инструкции PERFORM:

DO $$ BEGIN PERFORM gen_abra_cadabra(100);
END $$;


Поскольку функция возвращает строку, то нагляднее будет напечатать результат вызова этой функции:

DO $$ BEGIN RAISE NOTICE 'str = %', 
gen_abra_cadabra(100);
END $$;


В примере вызывается функция, и результат её работы помещается в переменную txt. С помощью этой инструкции вы можете помещать и запрашивать данные из таблицы. 

CREATE 
OR REPLACE PROCEDURE just_print() AS $$ DECLARE txt TEXT;BEGIN 
SELECT 
  gen_abra_cadabra(35) INTO txt;
RAISE NOTICE 'txt = %', 
txt;
END $$ LANGUAGE 'plpgsql';

Например, если запрос возвращает единственное значение, то результат вы можете поместить в переменную:

CREATE 
OR REPLACE PROCEDURE get_Kuropatkin_phone() AS $$ DECLARE txt TEXT;BEGIN 
SELECT 
  phone 
FROM 
  clients 
WHERE 
  name = 'Куропаткин В В' INTO txt;
RAISE NOTICE 'txt = %', 
txt;
END $$ LANGUAGE 'plpgsql';

Если вы извлекаете целую строку из таблицы, то поместить её можно в переменную типа RECORD.
Если при формировании строки что-то пойдёт не так и возникнет ошибка, 
то она будет обработана с помощью инструкции EXCEPTION WHEN OTHERS THEN и вместо сообщения об ошибке будет напечатана строка “You made a mistake!”.

CREATE 
OR REPLACE FUNCTION print_client_data() RETURNS VOID AS $$ DECLARE client RECORD;
BEGIN 
SELECT 
  * 
FROM 
  clients 
WHERE 
  name = 'Иван Владиморович К' INTO client;
RAISE NOTICE 'Имя клиента = %, телефон = %', 
client.name, 
client.phone;
EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'You made a mistake!';
END $$ LANGUAGE 'plpgsql';


С помощью инструкции FOR … IN вы можете пройти по всем записям, которые возвращает запрос. 
После ключевого слова FOR необходимо указать имя переменной, которая будет использоваться для итерации. 
В нашей случае это переменная rec с типом RECORD. В конструкции IN вам необходимо указать запрос. Внутри блока LOOP объявляется тело цикла.

DO $$ DECLARE rec RECORD;
BEGIN FOR rec IN 
SELECT 
  id, 
  name, 
  phone 
FROM 
  clients 
ORDER BY 
  name DESC LOOP RAISE NOTICE 'id = %, name = %, phone = %', 
  rec.id, 
  rec.name, 
  rec.phone;
END LOOP;
END $$;


Для удаления процедуры или функции используется следующий синтаксис:

DROP 
  PROCEDURE имя_процедуры;
DROP 
  FUNCTION имя_функции;




Добавьте в таблицу с заказами поле date_changed. Записывайте туда текущее время каждый раз, когда меняется значение какого либо поля в строке.

Посмотреть ответ для самопроверки
-- Добавляем поле date_changed
ALTER TABLE orders ADD COLUMN date_changed TIMESTAMP;
-- Создаём функцию
CREATE OR REPLACE FUNCTION update_date_changed() RETURNS TRIGGER AS $$
BEGIN
   NEW.date_changed = now();
   RETURN NEW;  
END;
$$ language 'plpgsql';
-- Создаём построчный BEFORE триггер
CREATE TRIGGER update_date_changed_triger
BEFORE UPDATE ON orders
FOR EACH ROW EXECUTE PROCEDURE update_date_changed();