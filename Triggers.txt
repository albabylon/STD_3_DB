Триггер — это хранимая процедура специального типа.

Триггеры используются, чтобы автоматически выполнять какие-то действия в базе. 
Например, каждый раз, когда вы обновляете запись в таблице и хотите сохранить дату этого обновления.

Триггеры можно настраивать очень гибко, например для команды UPDATE можно установить триггер так, 
чтобы он срабатывал, только если обновляются определённые столбцы. 
Вся эта логика описывается в функции, которая ассоциирована с триггером. Одна и та же функция может использоваться в разных триггерах. 
Это очень похоже на методы в программировании, когда вы выносите какую-то логику в отдельный метод и после используете его в разных местах. 
Важно, что триггерная функция должна быть создана до триггера. Она должна быть объявлена без аргументов и возвращать тип TRIGGER.

Если триггерная функция выполняет команды SQL, эти команды могут заново запускать триггеры. Это называется каскадными триггерами.

Будьте осторожны, ведь каскадные вызовы могут привести к рекурсивному срабатыванию одного и того же триггера. 
Например, в триггере INSERT может выполняться команда, которая добавляет строку в эту же таблицу, тем самым опять вызывая триггер на INSERT. 

Давайте напишем код функции, которая будет печатать имена всех клиентов:

CREATE 
OR REPLACE FUNCTION print_all_clients() RETURNS TRIGGER AS $$ DECLARE rec RECORD;BEGIN FOR rec IN 
SELECT 
  id, 
  name, 
  phone 
FROM 
  clients 
ORDER BY 
  name DESC LOOP RAISE NOTICE 'id = %, name = %, phone = %', 
  rec.id, 
  rec.name, 
  rec.phone;
END LOOP;
RETURN NULL;
--объясним дальше
END$$ LANGUAGE 'plpgsql';

После того как вы описали всю логику работы триггера в функции, вы можете создать триггер с помощью предложения CREATE TRIGGER:
Триггер на уровне оператора:

CREATE TRIGGER print_clients_trigger 
AFTER 
  INSERT ON clients EXECUTE PROCEDURE print_all_clients();

Триггер может быть определён на уровне строк (построчный триггер):
CREATE TRIGGER some_trigger 
AFTER 
  INSERT ON t1 FOR EACH ROW EXECUTE PROCEDURE f();

Это определяет, сколько раз будет вызвана триггерная функция при срабатывании триггера. 
В случае построчного триггера функция вызывается один раз для каждой строки, которую вы меняете. 
Операторный же триггер вызывается только один раз при выполнении соответствующего оператора, независимо от количества строк, которые он затрагивает. 
Такой триггер сработает, даже если ни одна строка не меняется оператором. 
В данном примере мы создали триггер, который будет срабатывать каждый раз, когда мы будем добавлять запись в таблицу с клиентами. 
После этого он будет печатать информацию о клиентах в output.


_________________________________________________________________________________________________________________
Когда срабатывает триггер

Триггер может срабатывать до, после или вместо какой-то операции. 
Они называются триггерами BEFORE, AFTER и INSTEAD OF соответственно. 
Триггеры BEFORE уровня оператора/строки срабатывают до того, как оператор/строка начинает делать что-либо.


Допустим, вы создали таблицу для хранения информации о работниках магазина. 
Вы хотите автоматически проверять, что при добавлении или изменении записей в этой таблице не были допущены ошибки. 
Для этого вы объявляете функцию check_emp, в которой будут выполнятся все эти проверки:

CREATE TABLE emp (
     empname text, -- имя сотрудника
     salary integer, -- зарплата
     last_date timestamp -- время последнего обновления записи
     );
CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
      BEGIN
         -- Проверить, что указаны имя сотрудника и зарплата
         IF NEW.empname IS NULL THEN
             RAISE EXCEPTION 'empname cannot be null';
         END IF;
         IF NEW.salary IS NULL THEN
             RAISE EXCEPTION '% cannot have null salary', NEW.empname;
         END IF;

         -- Кто будет работать, если за это надо будет платить?
         IF NEW.salary < 0 THEN
             RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
         END IF;

         -- Запомнить, когда изменена запись
         NEW.last_date := current_timestamp;

         RETURN NEW;
      END;
$emp_stamp$ LANGUAGE plpgsql;


В теле функции используется переменная NEW, которую мы не объявляли. 
Эта переменная хранит в себе информацию о новой записи. 
Именно это значение должен вернуть ваш триггер, чтобы скрипт продолжил работу корректно. 
После описания функции вам остаётся только создать триггер.

