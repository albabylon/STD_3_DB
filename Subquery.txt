Подзапросы

Представьте себе ситуацию: вы хотите посчитать среднюю стоимость товаров в категории, а потом получить максимальное значение

В одном запросе вы не можете несколько раз использовать агрегацию данных. 
В такой ситуации и можно использовать предвыборки, а именно, конструкцию следующего вида:
Здесь важным является то, что для вложенного запроса обязательно необходимо указать алиас с помощью конструкции AS.

SELECT 
  * 
FROM 
  (
    SELECT 
      ....
  ) AS tmp;


Для нашего примера с максимальной средней стоимостью по категории запрос будет выглядеть следующим образом:
Обратите внимание, что мы использовали алиас не только для задания имени подзапросу, но и для имени колонки — avg_price.

SELECT 
  MAX(t.avg_price) 
FROM 
  (
    SELECT 
      category, 
      AVG(price) as avg_price 
    FROM 
      products 
    GROUP BY 
      category
  ) as t;


Без WITH:

SELECT 
  client_id, 
  AVG(order_price) AS avg_order_price 
FROM 
  (
    SELECT 
      order_id, 
      SUM(price * amount) AS order_price 
    FROM 
      positions 
      JOIN PRODUCTS ON products.ID = positions.PRODUCT_ID 
    GROUP BY 
      POSITIONS.order_id
  ) AS order_sum 
  JOIN orders ON orders.id = order_sum.order_id 
GROUP BY 
  client_id 
ORDER BY 
  avg_order_price DESC;



Предложение WITH
Проблема использования предвыборок в том, что запросы с ними сложно читать. Для того чтобы решить эту проблему, используется предложение WITH.

WITH order_total AS (
  SELECT 
    order_id, 
    SUM(price * amount) AS order_price 
  FROM 
    positions 
    JOIN PRODUCTS ON products.ID = positions.PRODUCT_ID 
  GROUP BY 
    POSITIONS.order_id
) 
SELECT 
  client_id, 
  AVG(order_price) AS avg_order_price 
FROM 
  order_total 
  JOIN orders ON orders.id = order_total.order_id 
GROUP BY 
  client_id 
ORDER BY 
  avg_order_price DESC;



С помощью этой конструкции вы можете реализовывать и более сложные вещи. 
Если указать ключевое слово RECURSIVE, то WITH сможет обращаться к собственному результату. 
Давайте рассмотрим на примере. Просуммируем числа от 1 до 100:

WITH RECURSIVE t(n) AS (
  VALUES 
    (1) --создаёт таблицу с единственным значением, которое равно 1
  UNION ALL 
  SELECT 
    n + 1 
  FROM 
    t 
  WHERE 
    n < 100 --рекурсивная часть
    ) 
SELECT 
  sum(n) 
FROM 
  t;

RECURSEVE позволяет запросу обращаться к своим же выходным данным. Запрос при этом состоит из двух частей. 
Первая часть — это основа, обычно возвращающая одну строку. 
В примере это одна строка, с одним значением равным единице. 
Это база рекурсии, место, с которого начинаются все вычисления. 
Вторая часть — рекурсивная. 
Эта часть обращается ко временной таблице, которую мы объявили после WITH. 
Первая и вторая части объединяются оператором UNION или UNION ALL. 

Работает это всё следующим образом:
На первом шаге предложение FROM берёт значение из базы рекурсии.
Эти данные подставляем в «рекурсивную» часть запроса.
Если рекурсивная часть выполнилась и в результате появились какие-то данные, то они добавляются в результирующую выборку. 
Эти же данные используются для следующего вызова рекурсивной части, т.е. переходим на шаг 2.
Если рекурсивная часть не выполнилась, то выполнения заканчивается.


Рекурсивные запросы обычно применяются для работы с иерархическими или древовидными структурами данных. 
Например, в таблице с клиентами вы можете указывать идентификатор другого клиента, который его пригласил, того клиента тоже кто-то пригласил и так далее. 
С помощью рекурсивного запроса вы сможете построить цепочку и найти связи между пользователями.