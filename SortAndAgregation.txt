______________________________________________________________
1 Для того чтобы выбрать из таблицы только уникальные данные, используется оператор DISTINCT:
select 
  distinct fields 
from 
  table_with_duplicate;

2 Определённый порядок строк гарантируется, только если сортировка задана явно. 
Сделать это можно с помощью предложения ORDER BY:

SELECT 
  список_выборки 
FROM 
 таблица 
ORDER BY 
  условие_сортировки1 [ASC | DESC][, 
  условие_сортировки[ASC | DESC]...]

Когда указывается несколько условий сортировки, 
то каждое следующее условие позволяет отсортировать строки, 
в которых совпали все значения, участвующие в предыдущей сортировке.

Каждое выражение можно дополнить ключевыми словами ASC или DESC, которые выбирают сортировку соответственно по возрастанию или убыванию

______________________________________________________________
Агрегация данных
Агрегатная функция вычисляет единственное значение, обрабатывая множество строк:
count (количество строк), sum (сумму значений), avg (среднее значение), max и min

select 
  avg(price) 
from 
  products;

Обратите внимание, что нельзя использовать агрегатные функции в предложении WHERE!!!


Агрегатные функции также очень полезны в сочетании с предложением GROUP BY:
SELECT столбцы FROM таблица [WHERE условие_фильтрации_строк]
[GROUP BY столбцы_для_группировки] [HAVING условие_фильтрации_групп]
[ORDER BY столбцы_для_сортировки]

Оператор GROUP BY определяет, как строки будут группироваться.
select 
  address 
from 
  orders 
group by 
  address;

GROUP BY становится гораздо полезней, если использовать его с агрегатными функциями
select 
  address, 
  count(*) as order_count 
from 
  orders 
group by 
  address 
order by 
  order_count desc;

Первый столбец в выражении SELECT — address представляет название города, и по нему строки в таблице группируются, 
а второй столбец — order_count представляет результат функции COUNT, которая вычисляет количество строк в группе.

При этом важно знать, что любые столбцы, которые используются в выражении SELECT (не считая столбцов, которые хранят результат агрегатных функций), 
должны быть указаны после оператора GROUP BY.



Важным является то, что вы не можете использовать вложенные агрегатные функции. Например, если мы хотим найти среднюю стоимость товара в категории, 
а потом взять максимальную из этих стоимостей, то мы не сможем сделать это с помощью следующего запроса:
(НЕЛЬЗЯ ТАК!)
select 
  max(
    avg(price)
  ) as avg_price 
from 
  products 
group by 
  category;

Этот запрос можно переписать с использованием вложенного подзапроса:
select 
  max(tmp.avg_price) 
from 
  (
    select 
      category as c, 
      avg(price) as avg_price 
    from 
      products 
    group by 
      category
  ) as tmp;

Обратите внимание, что вложенный запрос находится в скобках. Результатом выполнения является временная таблица tmp. 
Если вы используете вложенный запрос в выражении FROM, то обязательно нужно использовать AS для присвоения алиаса временной таблице. 


В запросах с GROUP BY может быть оператор HAVING. 
Этот оператор определяет, какие группы будут включены в выходной результат, то есть выполняет фильтрацию групп.
По сути HAVING похож на WHERE, с тем лишь отличием, что WHERE применяется к фильтрации строк, а HAVING используется для фильтрации групп.
select 
  category, 
  count(*) 
from 
  products 
group by 
  category 
having 
  count(*) > 3;

______________________________________________________________
______________________________________________________________
______________________________________________________________

