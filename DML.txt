DDL - INSERT, UPDATE, DELETE, SELECT

INSERT, DELETE и UPDATE обращаются только к одной таблице.

---------------------------------------------------------
INSERT

INSERT INTO clients (name, phone, email) 
VALUES 
(
'Кое Кто', '80932334444', 'koe_kto@mail.ru'
);

Старайтесь всегда задавать список столбцов при добавлении данных в таблицу.

Когда вы добавляете в таблицу значения и не указываете имена столбцов, то типы этих значений должны соответствовать типам целевых столбцов


При добавлении данных можно указать, что делать в случае возникновения конфликта
INSERT INTO products (id, name, price, category) 
VALUES 
(
	1, 'Шампунь 2', 1200, 'косметика'
) ON CONFLICT DO NOTHING;


После предложения ON CONFLICT можно написать DO UPDATE. Это гарантирует, что либо новое значение будет добавлено в таблицу, 
т.е. выполнится команда INSERT, или же значение в таблице будет обновлено, а значит выполнится команда UPDATE.

Эта операция также известна как UPSERT — UPDATE или INSERT. Синтаксис у этой операции следующий:

INSERT INTO clients (id, name, phone, email) 
VALUES 
  (
    9, 'Анна Васильевна Орешкина', 
    '805565423422', 'anna@mail.com'
  ) ON CONFLICT (id) DO 
UPDATE 
SET 
  name = EXCLUDED.name, 
  phone = EXCLUDED.phone, 
  email = EXCLUDED.email;

Для обращения к значениям, изначально предлагаемым для добавления, используется специальная таблица excluded


Мы рассмотрели однострочный INSERT, кроме этого существует возможность добавлять сразу несколько строк в таблицу, используя подзапросы
 Это может быть полезно, когда вы формируете какой-то отчёт. 
 Или, например, вы хотите сохранить информацию обо всех заказах, которые были сделаны в прошлом году, для того чтобы освободить таблицу с заказами в начале года.

Создадим таблицу, в которой сохраним все старые заказы:
CREATE TABLE old_orders (
  id integer PRIMARY KEY, 
  client_id integer NOT NULL REFERENCES clients(id), 
  date date NOT NULL, 
  status character varying(100) NOT NULL CHECK (
    status IN (
      'done', 'in progress', 'delivery'
    )
  ), 
  address character varying(100) NOT NULL
);

Теперь давайте добавим в эту таблицу все заказы, которые были сделаны до 1 января 2020 года:
INSERT INTO old_orders (
  id, client_id, date, status, address
) (
  SELECT 
    id, 
    client_id, 
    date, 
    status, 
    address 
  FROM 
    orders 
  WHERE 
    date < '2020-01-01'
);

Эту же операцию можно выполнить с помощью сокращённого синтаксиса, главное, чтобы количество и типы столбцов совпадали:
INSERT INTO old_orders 
SELECT 
  * 
FROM 
  orders 
WHERE 
  date < '2020-01-01';

Например, если вы часто выполняете запрос, который объединяет несколько таблиц, то, может быть, 
создание новой таблицы с необходимыми данными увеличит скорость выполнения запросов, 
потому что поиск по одной таблице обычно работает быстрее, чем поиск по нескольким таблицам.



---------------------------------------------------------
UPDATE

Иногда может возникнуть необходимость обновить информацию, которая хранится в базе данных. 
Например, клиент изменил количество товаров в заказе, а значит необходимо изменить значение в таблице ORDERS.

UPDATE 
  clients 
SET 
  phone = 85553332211 
WHERE 
  name = 'Иванов Иван Иванович';

UPDATE изменяет значения указанных столбцов во всех строках, удовлетворяющих условию WHERE
В предложении SET перечисляются только те столбцы, которые будут изменены

Аналогично инструкции INSERT, в инструкции UPDATE вы можете использовать подзапросы и обращаться к разным таблицам


Увеличим количество позиций в его заказах с помощью вложенного запроса в предложении WHERE:\
UPDATE 
  positions 
SET 
  amount = amount + 1 
WHERE 
  order_id IN (
    SELECT 
      id 
    FROM 
      orders 
    WHERE 
      orders.client_id = (
        SELECT 
          id 
        FROM 
          clients 
        WHERE 
          name = 'Бук Василий Петрович'
      )
  );

То же самое можно сделать с помощью предложения FROM:
UPDATE 
  positions 
SET 
  amount = amount + 1 
FROM 
  orders 
WHERE 
  orders.client_id = (
    SELECT 
      id 
    FROM 
      clients 
    WHERE 
      name = 'Бук Василий Петрович'
  ) 
  AND positions.order_id = orders.id;

В запросе выше мы объединили две таблицы — orders и positions — и после этого отфильтровали строки. 
Когда присутствует предложение FROM, целевая таблица, по сути, соединяется с таблицами, перечисленными в элементе FROM.

Если вы используете предложение FROM, то целевая строка не должна соединяться с более чем одной строкой из других таблиц. 
Если это условие нарушается, только одна из строк соединения будет использоваться для изменения целевой строки, но какая именно, предсказать нельзя. 
По этой причине лучше использовать подзапросы, хотя они часто хуже читаются и работают медленнее, чем соединение таблиц через FROM.

---------------------------------------------------------
DELETE

DELETE FROM 
  clients 
WHERE 
  id = 111;

В предложении WHERE вы можете использовать подзапросы. При выполнении запроса на удаление данных все строки таблицы последовательно проверяются на соответствие условию отбора. 
Строки, для которых условие выполняется, удаляются, а остальные сохраняются без изменений.

В инструкции DELETE запрещено использовать соединение таблиц, т.е. инструкция DELETE с параллельным удалением из двух таблиц не сработает.